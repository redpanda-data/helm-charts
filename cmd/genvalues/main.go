package main

import (
	"encoding/json"
	"fmt"

	jsonpatch "github.com/evanphx/json-patch"
	"github.com/invopop/jsonschema"
	"github.com/redpanda-data/helm-charts/charts/redpanda"
)

func Must[T any](value T, err error) T {
	if err != nil {
		panic(err)
	}
	return value
}

func main() {
	r := &jsonschema.Reflector{
		//  These values are set to minimize the diff between the
		// handwritten jsonschema and the generated jsonschema.
		ExpandedStruct: true,
		DoNotReference: true,

		// For backwards compatibility, don't "close" our objects. There are
		// many fields that are not currently represented. Setting this to
		// false, the default and recommended value, will break many existing
		// installs. TestTemplate will catch many of these breakages.
		AllowAdditionalProperties: true,

		// jsonschema, by default, will rely on omitempty flags to determine if
		// a value is required or not. This has too much of an impact on how
		// the underlying JSON is shaped and marshalled/unmarshalled. Instead,
		// rely on explicitly set required tags.
		RequiredFromJSONSchemaTags: true,
	}
	s := r.Reflect(&redpanda.Values{})

	var schema map[string]any
	if err := json.Unmarshal(Must(json.Marshal(s)), &schema); err != nil {
		panic(err)
	}

	// Leave a note to dissuade any would be manual editors.
	s.Description = "DO NOT EDIT!. This file was generated by ./cmd/genvalues/genvalues.go"

	data, err := json.Marshal(OneOfToTypeArray(schema))
	if err != nil {
		panic(err.Error())
	}

	// First Block: Small Fixes to the metaschema values for backwards compat.
	// These can be removed after the initial migration.

	// Second Block: Corrections for inconsistencies within our handwritten
	// jsonschema. It's likely that these can be removed without adverse
	// affects after the initial migration.

	// Third Block: Work around limitations in the jsonschema library when
	// dealing with nullables. These can be replaced with oneof_type
	// annotations after the initial migration.

	// Fourth Block: Work around some issues with oneof_type and pattern being
	// set on the same field. Again, this can be worked around with some tweaks
	// to how the schema is generated and can be removed after the initial migration.
	patch := Must(jsonpatch.DecodePatch([]byte(`[
		{"op": "remove", "path": "/$id"},
		{"op": "replace", "path": "/$schema", "value": "http://json-schema.org/schema#"},

		{"op": "replace", "path": "/properties/listeners/properties/schemaRegistry/properties/external/patternProperties/^[A-Za-z_][A-Za-z0-9_]*$/properties/tls/required", "value": []},
		{"op": "replace", "path": "/properties/listeners/properties/http/properties/external/patternProperties/^[A-Za-z_][A-Za-z0-9_]*$/required", "value": ["port"]},
		{"op": "replace", "path": "/properties/listeners/properties/http/properties/external/patternProperties/^[A-Za-z_][A-Za-z0-9_]*$/properties/tls/required", "value": []},
		{"op": "replace", "path": "/properties/storage/properties/tieredConfig/properties/cloud_storage_cache_size/type", "value": "integer"},
		{"op": "add", "path": "/properties/storage/properties/tiered/properties/config/required/0", "value": "cloud_storage_enabled"},

		{"op": "replace", "path": "/properties/auditLogging/properties/enabledEventTypes/type", "value": ["array", "null"]},
		{"op": "replace", "path": "/properties/auditLogging/properties/excludedPrincipals/type", "value": ["array", "null"]},
		{"op": "replace", "path": "/properties/auditLogging/properties/excludedTopics/type", "value": ["array", "null"]},
		{"op": "replace", "path": "/properties/listeners/properties/http/properties/authenticationMethod/type", "value": ["string", "null"]},
		{"op": "replace", "path": "/properties/listeners/properties/kafka/properties/authenticationMethod/type", "value": ["string", "null"]},

		{"op": "add", "path": "/properties/listeners/properties/schemaRegistry/properties/authenticationMethod/pattern", "value": "http_basic|none"},
		{"op": "add", "path": "/properties/listeners/properties/http/properties/external/patternProperties/^[A-Za-z_][A-Za-z0-9_]*$/properties/authenticationMethod/pattern", "value": "http_basic|none"},
		{"op": "add", "path": "/properties/listeners/properties/kafka/properties/external/patternProperties/^[A-Za-z_][A-Za-z0-9_]*$/properties/authenticationMethod/pattern", "value": "sasl|none|mtls_identity"},
		{"op": "add", "path": "/properties/listeners/properties/schemaRegistry/properties/external/patternProperties/^[A-Za-z_][A-Za-z0-9_]*$/properties/authenticationMethod/pattern", "value": "http_basic|none"}
	]`)))

	fmt.Printf("%s\n", Must(patch.ApplyIndent(data, "  ")))
}

// OneOfToTypeArray compacts the options of a oneOf array into an array of types.
// For example oneOf: [{type: string}, {type: null}] -> type: [string, null]
// This is just to further reduce the generated diff during the migration to a
// generated json schema and may be removed after the initial migration.
func OneOfToTypeArray(schema map[string]any) map[string]any {
	if oneOf, ok := schema["oneOf"]; ok && len(schema) == 1 {
		types := make([]string, len(oneOf.([]any)))
		for i, opt := range oneOf.([]any) {
			types[i] = opt.(map[string]any)["type"].(string)
		}
		delete(schema, "oneOf")
		schema["type"] = types
		return schema
	}

	for key, value := range schema {
		switch value := value.(type) {
		case map[string]any:
			schema[key] = OneOfToTypeArray(value)
		}
	}

	return schema
}
